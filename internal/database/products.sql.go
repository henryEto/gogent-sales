// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"
	"strings"
)

const getListOfProducts = `-- name: GetListOfProducts :many
WITH product_sales AS (
  SELECT
    a.vcodpro AS codigo,
    a.vdescri AS descripcion,
    l.vdescri AS linea,
    a.vsublin AS sublinea,
    a.vmarart AS marca,
    SUM(m.vcantid) AS cantidad_vendida,
    COUNT(m.vcodpro) AS num_ventas
  FROM articulos a
  JOIN lineas l ON a.vlinart = l.vlindep
  INNER JOIN movimientosd m
    ON a.vcodpro = m.vcodpro
  WHERE
    a.vtippro = 1
    AND a.vdescri != ''
    AND a.vlinart NOT IN ('9', '13')
    AND STR_TO_DATE(m.vfecham, '%Y-%m-%d') >= CURDATE() - INTERVAL 30 DAY
    AND m.vtipmov = 'caj01'
    AND m.vcantid > 0
  GROUP BY
    a.vcodpro, a.vdescri, l.vdescri, a.vsublin, a.vmarart
)
SELECT
  ps.codigo,
  ps.descripcion,
  ps.linea,
  ps.sublinea,
  ps.marca,
  CAST((ps.cantidad_vendida * 1.0 / SUM(ps.cantidad_vendida) OVER ()) * 70.0 +
  (ps.num_ventas * 1.0 / SUM(ps.num_ventas) OVER ()) * 30.0 AS DECIMAL(10,4)) AS score_popularidad
FROM product_sales ps
WHERE ps.cantidad_vendida > 0
ORDER BY
  score_popularidad DESC
`

type GetListOfProductsRow struct {
	Codigo           string
	Descripcion      string
	Linea            string
	Sublinea         string
	Marca            string
	ScorePopularidad string
}

// sql/queries/products.sql
func (q *Queries) GetListOfProducts(ctx context.Context) ([]GetListOfProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getListOfProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListOfProductsRow
	for rows.Next() {
		var i GetListOfProductsRow
		if err := rows.Scan(
			&i.Codigo,
			&i.Descripcion,
			&i.Linea,
			&i.Sublinea,
			&i.Marca,
			&i.ScorePopularidad,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsInfo = `-- name: GetProductsInfo :many
WITH product_sales AS(
SELECT
    a.vcodpro AS codigo,
    a.vdescri AS descripcion,
    l.vdescri AS linea,
    a.vsublin AS sublinea,
    a.vmarart AS marca,
    a.vexiact as existencia,
    SUM(m.vcantid) AS cantidad_vendida,
    COUNT(m.vcodpro) AS num_ventas,
    a.vmedpes as peso_prom_caja,
    a.vpresen AS piezas_por_caja,
    a.vmedpes / a.vpresen AS preo_prom_pieza,
    g.fac1 AS precio_detalle,
    g.facd1 AS escala_detalle,
    g.fac2 AS precio_medio_mayoreo,
    g.facd2 AS escala_medio_mayoreo,
    g.fac3 AS precio_mayoreo,
    g.facd3 AS escala_mayoreo,
    g.fac4 AS precio__especial,
    g.facd4 AS escala_especial
FROM articulos a
JOIN lineas l ON a.vlinart = l.vlindep
JOIN grupos g ON a.vcodpro = g.grupo
  INNER JOIN movimientosd m ON a.vcodpro = m.vcodpro
WHERE
    a.vcodpro IN (/*SLICE:product_codes*/?)
    AND STR_TO_DATE(m.vfecham, '%Y-%m-%d') >= CURDATE() - INTERVAL 30 DAY
    AND m.vtipmov = 'caj01'
    AND m.vcantid > 0
GROUP BY
    a.vcodpro, a.vdescri, l.vdescri, a.vsublin, a.vmarart
)
SELECT
  ps.codigo,
  ps.descripcion,
  ps.linea,
  ps.sublinea,
  ps.marca,
  ps.existencia,
  CAST((ps.cantidad_vendida * 1.0 / SUM(ps.cantidad_vendida) OVER ()) * 70.0 +
  (ps.num_ventas * 1.0 / SUM(ps.num_ventas) OVER ()) * 30.0 AS DECIMAL(10,4)) AS score_popularidad,
  ps.peso_prom_caja,
  ps.preo_prom_pieza,
  ps.precio_detalle,
  ps.escala_detalle,
  ps.precio_medio_mayoreo,
  ps.escala_medio_mayoreo,
  ps.precio_mayoreo,
  ps.escala_mayoreo,
  ps.precio__especial,
  ps.escala_especial
FROM product_sales ps
WHERE ps.cantidad_vendida > 0
ORDER BY
  score_popularidad DESC
`

type GetProductsInfoRow struct {
	Codigo             string
	Descripcion        string
	Linea              string
	Sublinea           string
	Marca              string
	Existencia         float64
	ScorePopularidad   string
	PesoPromCaja       float64
	PreoPromPieza      interface{}
	PrecioDetalle      float64
	EscalaDetalle      string
	PrecioMedioMayoreo float64
	EscalaMedioMayoreo string
	PrecioMayoreo      float64
	EscalaMayoreo      string
	PrecioEspecial     float64
	EscalaEspecial     string
}

func (q *Queries) GetProductsInfo(ctx context.Context, productCodes []string) ([]GetProductsInfoRow, error) {
	query := getProductsInfo
	var queryParams []interface{}
	if len(productCodes) > 0 {
		for _, v := range productCodes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_codes*/?", strings.Repeat(",?", len(productCodes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_codes*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsInfoRow
	for rows.Next() {
		var i GetProductsInfoRow
		if err := rows.Scan(
			&i.Codigo,
			&i.Descripcion,
			&i.Linea,
			&i.Sublinea,
			&i.Marca,
			&i.Existencia,
			&i.ScorePopularidad,
			&i.PesoPromCaja,
			&i.PreoPromPieza,
			&i.PrecioDetalle,
			&i.EscalaDetalle,
			&i.PrecioMedioMayoreo,
			&i.EscalaMedioMayoreo,
			&i.PrecioMayoreo,
			&i.EscalaMayoreo,
			&i.PrecioEspecial,
			&i.EscalaEspecial,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
